<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>술보다 대마 음료가 건강에 좋을까요?</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&family=IBM+Plex+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 폰트 설정 */
        body { font-family: 'Nanum Gothic', sans-serif; }
        /* 어휘 목록 사이드바 폰트 */
        .vocab-sidebar { font-family: 'IBM Plex Sans KR', sans-serif; }
        /* 어휘 팝업 스타일 */
        .vocab-popup { font-family: 'Nanum Gothic', sans-serif; z-index: 50; max-width: 320px; white-space: normal; }
        /* 호버 툴팁 스타일 */
        .hover-tooltip { position: fixed; z-index: 9999; background: white; border: 2px solid #22c55e; border-radius: 8px; padding: 12px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); max-width: 320px; font-family: 'Nanum Gothic', sans-serif; animation: fadeIn 0.15s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
        /* 일반 어휘 강조 스타일 */
        .highlight-general { font-weight: 600; color: #374151; cursor: pointer; position: relative; transition: background-color 0.2s; }
        /* 마우스 호버 또는 활성화 시 스타일 */
        .highlight-general:hover, .active-highlight { background-color: #dcfce7; border-radius: 3px; }
        .script-highlight { background-color: #e0f2fe; border-radius: 8px; }
        .vocab-highlight { background-color: #dcfce7; border: 2px solid #22c55e; border-radius: 8px; }

        /* --- 말풍선 스타일 --- */
        /* Updated tail styles to match new class names */
        .bubble-tail-left.bubble-kkn20::after { /* Yuna Style 1 */
            content: "";
            position: absolute;
            bottom: 6px;
            left: -8px;
            width: 0px;
            height: 0px;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid #dcfce7; /* green-100 */
            transition: border-color 0.3s;
        }
        /* Add style for Yuna Style 2 if needed */
        /* .bubble-tail-left.bubble-kkn30::after { ... } */

        .bubble-tail-right.bubble-other::after { /* Woody Style */
            content: "";
            position: absolute;
            bottom: 6px;
            right: -8px;
            width: 0px;
            height: 0px;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 8px solid white;
            transition: border-color 0.3s;
        }

        /* Active styles targeting new classes */
        .bubble-active.bubble-tail-left.bubble-kkn20::after,
        /* Add active style for Yuna Style 2 if needed */
        /* .bubble-active.bubble-tail-left.bubble-kkn30::after, */
        .bubble-active.bubble-tail-right.bubble-other::after {
            border-right-color: #fef9c3; /* yellow-100 */
            border-left-color: #fef9c3; /* yellow-100 */
        }


        /* --- 디바이스별 레이아웃 스타일 --- */
        /* These rules are removed as layout is now handled by responsive Tailwind classes in the component */
        
        /* 인쇄 전용 스타일 */
        .print-only { display: none; }
        @media print {
            @page { size: A4; margin: 0.75cm 1cm; }
            .no-print { display: none !important; }
            .print-only { display: inline-block !important; }
            body, html { background: white !important; font-size: 9pt; }
            .mx-auto { max-width: none !important; padding: 0 !important; margin: 0 !important; border: none !important; box-shadow: none !important; }
            body > #root > div { padding: 0 !important; }
            * { box-shadow: none !important; border-color: transparent !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
            p, h1, h2, h3, h4, span, li { color: black !important; }
            p, li { line-height: 1.5; }
            header.text-center { margin-bottom: 1rem !important; }
            .pt-10 { padding-top: 1rem !important; }
            .mb-8 { margin-bottom: 0.4pt !important; }
            h1, h2 { font-size: 12pt !important; margin-bottom: 15px; }
            h3 { font-size: 12pt !important; margin-bottom: 10px; }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>
    <script type="text/babel">
        /**
         * @typedef {Object} ScriptLine
         * @property {string} id - Unique identifier (e.g., 's1')
         * @property {string} speaker - Speaker name ('유나' | '우디')
         * @property {string} kor - Korean text
         * @property {string} eng - English translation
         * @property {[number, number]} [time] - Optional [start, end] timestamps
         */

        // --- 아이콘 컴포넌트 ---
        const Icon = React.memo(({ children, className = 'w-6 h-6' }) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>);
        const Video = ({ className }) => <Icon className={className}><path d="m22 8-6 4 6 4V8Z"></path><rect width="14" height="12" x="2" y="6" rx="2" ry="2"></rect></Icon>;
        const BookOpen = ({ className }) => <Icon className={className}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></Icon>;
        const MessageSquare = ({ className }) => <Icon className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></Icon>;
        const ThumbsUp = ({ className }) => <Icon className={className}><path d="M7 10v12"></path><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a2 2 0 0 1 3 1.88V5Z"></path></Icon>;
        const List = ({ className }) => <Icon className={className}><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></Icon>;
        const Spinner = ({ className = 'w-5 h-5' }) => (
            <svg className={`animate-spin ${className}`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        );

        // --- 공용 컴포넌트: 번역 버튼 ---
        const TranslateButton = React.memo(({ textToTranslate }) => {
            const { useState, useEffect, useRef, useCallback } = React;
            const [translation, setTranslation] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [show, setShow] = useState(false);
            const [buttonLang, setButtonLang] = useState('Translation');
            const isMounted = useRef(true);

            useEffect(() => {
                isMounted.current = true;
                setButtonLang('English');
                return () => { isMounted.current = false; };
            }, []);

            const handleTranslate = useCallback(async () => {
                if (show) { setShow(false); return; }
                if (translation) { setShow(true); return; }
                if (!textToTranslate.trim()) return;

                setIsLoading(true);
                setError(null);
                try {
                    const targetLanguage = 'English';
                    const prompt = `Translate the following Korean text to ${targetLanguage}. Provide only the most natural-sounding translation, without any additional explanations or quotation marks.`;
                    const payload = { contents: [{ role: "user", parts: [{ text: prompt }, { text: textToTranslate }] }] };
                    // NOTE: The API key is intentionally left blank.
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API Error: ${response.status}`);
                    const result = await response.json();
                    if (isMounted.current && result.candidates?.[0]?.content.parts[0].text) {
                        setTranslation(result.candidates[0].content.parts[0].text.trim());
                        setShow(true);
                    } else { throw new Error("Invalid API response format."); }
                } catch (err) { if (isMounted.current) setError("번역에 실패했어요."); }
                finally { if (isMounted.current) setIsLoading(false); }
            }, [show, translation, textToTranslate]);

            return (
                <div className="mt-1 no-print">
                    <button onClick={handleTranslate} disabled={isLoading} className="text-xs text-gray-500 hover:text-gray-800 font-semibold py-1 px-2 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors disabled:text-gray-300">{isLoading ? '번역 중...' : (show ? '번역 숨기기' : `번역 (${buttonLang})`)}</button>
                    {show && translation && <p className="text-gray-600 text-base mt-2 mb-2 whitespace-pre-wrap">{translation}</p>}
                    {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
                </div>
            );
        });

        // --- [동영상 자료] 탭 관련 컴포넌트 ---
        const HighlightedText = React.memo(({ text, highlightData, onWordHover, onWordLeave, onWordClick, lineId, activeWordId }) => {
            if (!text || !highlightData) return text;
            const { regex, wordMap, sortedWords } = highlightData;
            const parts = text.split(regex);
            return (<>{parts.map((part, index) => {
                if (!part) return null;
                if (index % 2 === 0) return part;
                const trimmedPart = part.trim();
                const baseForm = sortedWords.find(word => {
                    const vocabItem = wordMap.get(word);
                    if (vocabItem.variants && vocabItem.variants.includes(trimmedPart)) return true;
                    const cleanPart = trimmedPart.replace(/\s/g, '');
                    const cleanWord = word.replace(/\s/g, '');
                    if (word.endsWith('다')) return cleanPart.startsWith(cleanWord.slice(0, -1));
                    return cleanPart.startsWith(cleanWord);
                });
                if (!baseForm) return part;
                const info = wordMap.get(baseForm);
                if (!info) return part;
                const uniqueWordId = `${lineId}-${index}-${baseForm}`;
                const classes = ['highlight-general', 'font-bold', activeWordId === uniqueWordId ? 'active-highlight' : ''].join(' ');
                return <span
                    key={index}
                    className={classes}
                    onMouseEnter={(e) => onWordHover(e, baseForm, lineId, index)}
                    onMouseLeave={onWordLeave}
                    onClick={(e) => onWordClick(e, baseForm)}
                >{part}</span>;
            })}</>);
        });

        const HoverTooltip = React.memo(({ data, position }) => {
            if (!data || !position) return null;
            return (
                <div
                    className="hover-tooltip"
                    style={{ left: `${position.x}px`, top: `${position.y}px` }}
                >
                    <p className="font-bold text-lg text-green-700 mb-2">{data.term}</p>
                    <p className="text-gray-700 text-base">{data.mainDef}</p>
                    {data.subDefs && data.subDefs.length > 0 && (
                        <div className="mt-3 pt-3 border-t border-gray-200">
                            <ul className="space-y-1">
                                {data.subDefs.map((sub, i) => (
                                    <li key={i} className="text-sm">
                                        <span className="font-semibold text-gray-600">{sub.subTerm}:</span>{' '}
                                        <span className="text-gray-600">{sub.subDef}</span>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
            );
        });

        const VocabItem = React.memo(React.forwardRef(({ item, isHighlighted }, ref) => {
            const { useState } = React;
            const [showExamples, setShowExamples] = useState(false);

            return (
                <div ref={ref} className={`p-4 rounded-lg border-b ${isHighlighted ? 'vocab-highlight' : 'bg-white'}`}>
                    <p className="font-bold text-[18px] text-green-700">{item.term}</p>
                    <div className="pl-4 mt-2 border-l-2">
                        <p className="text-gray-700 text-[17px]">{item.mainDef}</p>
                        {item.subDefs && item.subDefs.length > 0 && (
                            <div className="mt-3 pt-3 border-t">{item.subDefs.map((sub, index) => (
                                <div key={index} className="mt-2">
                                    <p className="font-semibold text-[17px]">{sub.subTerm}</p>
                                    <p className="text-gray-600 pl-2 text-[16px]">{sub.subDef}</p>
                                </div>
                            ))}</div>
                        )}
                    </div>
                    {/* item.examples가 존재하고, 0개 이상일 때만 버튼을 렌더링합니다. */}
                    {item.examples && item.examples.length > 0 && (
                        <div className="mt-3 no-print">
                            <button onClick={() => setShowExamples(!showExamples)} className="text-xs bg-green-200 hover:bg-green-300 text-gray-600 py-1 px-2 rounded-md">
                                {showExamples ? 'Close Examples' : 'Sentence Examples'}
                            </button>
                            {/* showExamples가 true일 때 예문 목록을 보여줍니다. */}
                            {showExamples && (
                                <div className="mt-3 p-3 bg-green-50 rounded-lg space-y-3 text-[16px]">
                                    {item.examples.map((ex, index) => (
                                        <div key={index}>
                                            <p className="font-medium text-gray-800">{ex.kor}</p>
                                            <p className="text-gray-400 hover:text-gray-700 transition-colors">{ex.eng}</p>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }));

        const VideoMaterialsTab = ({scriptContent, vocabAndGrammarList, highlightData, vocabMap}) => {
            const { useState, useRef, useEffect, useCallback, useMemo } = React;
            const [activeWordId, setActiveWordId] = useState(null);
            const [player, setPlayer] = useState(null);
            const [activeScriptLine, setActiveScriptLine] = useState(null);
            const [isSyncEnabled, setIsSyncEnabled] = useState(true);
            const [hoverPopupData, setHoverPopupData] = useState(null);
            const [highlightedVocab, setHighlightedVocab] = useState(null);
            const [translationsVisible, setTranslationsVisible] = useState({});
            // const [playerHeight, setPlayerHeight] = useState(0); // 높이 동적 조절로 인해 제거
            const [isVocabSidebarVisible, setIsVocabSidebarVisible] = useState(true);
            const [isPortrait, setIsPortrait] = useState(window.matchMedia("(orientation: portrait)").matches);
            const [playbackRate, setPlaybackRate] = useState(0.65); // *** 기본 속도를 0.65x로 설정
            const [pinnedWordData, setPinnedWordData] = useState(null); // *** 팝업 고정 상태

            const scriptLineRefs = useRef({});
            const vocabRefs = useRef({});
            const intervalRef = useRef();
            const playerContainerRef = useRef(null);
            const hoverTimeoutRef = useRef(null);
            const scriptWrapperRef = useRef(null); // 스크롤 컨테이너를 위한 ref 추가
            const clipTimeoutRef = useRef(null); // 이 문장만 재생 타임아웃을 위한 ref

            const activeScriptLineRef = useRef(activeScriptLine);
            activeScriptLineRef.current = activeScriptLine;

            // --- Phase 2: Indexing for performance ---
            const timeIndex = useMemo(() => {
                return scriptContent
                    .filter(line => line.time)
                    .map(line => ({ start: line.time[0], end: line.time[1], id: line.id }))
                    .sort((a, b) => a.start - b.start);
            }, [scriptContent]);

            const onPlayerReady = useCallback((event) => {
                setPlayer(event.target);
                event.target.setPlaybackRate(playbackRate); // *** 플레이어 준비 시 현재 속도(0.65x) 설정
            }, [playbackRate]);

            const setupPlayer = useCallback(() => {
                if (window.YT && window.YT.Player) {
                    const newPlayer = new window.YT.Player('youtube-player', {
                        height: '100%',
                        width: '100%',
                        videoId: 'or55JENlG2k',
                        events: { 'onReady': onPlayerReady }
                    });
                    setPlayer(newPlayer);
                }
            }, [onPlayerReady]);

            useEffect(() => {
                const mediaQuery = window.matchMedia("(orientation: portrait)");
                const handleOrientationChange = (e) => setIsPortrait(e.matches);
                mediaQuery.addEventListener('change', handleOrientationChange);
                return () => mediaQuery.removeEventListener('change', handleOrientationChange);
            }, []);

            // *** 팝업 고정 해제를 위한 전역 클릭 리스너
            useEffect(() => {
                const handleGlobalClick = (e) => {
                    // 팝업이 고정되어 있고, 클릭한 대상이 하이라이트된 단어가 아닐 경우
                    if (pinnedWordData && !e.target.closest('.highlight-general')) {
                        setPinnedWordData(null);
                        setHighlightedVocab(null);
                    }
                };
                
                document.addEventListener('click', handleGlobalClick);
                return () => {
                    document.removeEventListener('click', handleGlobalClick);
                };
            }, [pinnedWordData]); // pinnedWordData 상태가 바뀔 때마다 이 effect를 재실행

            useEffect(() => {
                if (window.YT && document.getElementById('youtube-player')) {
                    if (!player) setupPlayer();
                } else if (!window.YT) {
                    window.onYouTubeIframeAPIReady = setupPlayer;
                }
                return () => { 
                    if (intervalRef.current) clearInterval(intervalRef.current); 
                    if (clipTimeoutRef.current) clearTimeout(clipTimeoutRef.current);
                };
            }, [setupPlayer, player]);

            // // 높이 동적 조절로 인해 제거
            // useEffect(() => {
            //     let ro;
            //     if (playerContainerRef.current) {
            //         const updateHeight = () => { if (playerContainerRef.current) setPlayerHeight(playerContainerRef.current.offsetHeight); };
            //         ro = new ResizeObserver(updateHeight);
            //         ro.observe(playerContainerRef.current);
            //         updateHeight();
            //     }
            //     return () => ro?.disconnect();
            // }, []);

            // playbackRate 상태가 변경되거나 player가 준비되면 속도 설정
            useEffect(() => {
                if (player && player.setPlaybackRate) {
                    player.setPlaybackRate(playbackRate);
                }
            }, [player, playbackRate]);

            useEffect(() => {
                if (player && isSyncEnabled) {
                    intervalRef.current = setInterval(() => {
                        if (player.getCurrentTime) {
                            const currentTime = player.getCurrentTime();
                            const currentLine = timeIndex.find(line => currentTime >= line.start && currentTime < line.end);
                            const currentLineId = currentLine ? currentLine.id : null;
                            if (activeScriptLineRef.current !== currentLineId) {
                                setActiveScriptLine(currentLineId);
                            }
                        }
                    }, 250);
                } else {
                    clearInterval(intervalRef.current);
                }
                return () => clearInterval(intervalRef.current);
            }, [player, isSyncEnabled, timeIndex]);

            // *** 스크롤 로직 수정 ***
            useEffect(() => {
                if (activeScriptLine && isSyncEnabled) {
                    const lineElement = scriptLineRefs.current[activeScriptLine];
                    const scriptWrapper = scriptWrapperRef.current; 

                    if (lineElement && scriptWrapper) {
                        const wrapperHeight = scriptWrapper.clientHeight; // 컨테이너의 보이는 높이
                        const lineTop = lineElement.offsetTop; // 스크롤 컨테이너 콘텐츠 기준 라인의 상단 위치
                        const lineHeight = lineElement.offsetHeight; // 라인의 높이
                        
                        // 스크롤 컨테이너의 총 스크롤 가능 높이
                        const maxScrollTop = scriptWrapper.scrollHeight - wrapperHeight;

                        // 1. 라인 요소의 중앙이 컨테이너의 중앙에 오도록 목표 스크롤 위치 계산
                        //    이것이 요청하신 "스크립트 랩퍼의 가운데 지점"입니다.
                        let targetScrollTop = lineTop - (wrapperHeight / 2) + (lineHeight / 2);

                        // 2. 랩퍼의 끝 부분(최대 스크롤)을 넘지 않도록 목표 위치를 제한
                        if (targetScrollTop > maxScrollTop) {
                            targetScrollTop = maxScrollTop;
                        }
                        // 3. 스크롤 위치가 0보다 작은 경우 0으로 설정
                        if (targetScrollTop < 0) {
                            targetScrollTop = 0;
                        }
                        
                        // 4. 계산된 위치로 스크롤
                        scriptWrapper.scrollTo({
                            top: targetScrollTop,
                            behavior: 'smooth'
                        });
                    }
                }
            }, [activeScriptLine, isSyncEnabled]);

            const handlePlayClip = (line) => {
                if (!player || !line.time) return;

                // 이미 실행 중인 타임아웃이 있다면 취소
                if (clipTimeoutRef.current) {
                    clearTimeout(clipTimeoutRef.current);
                }

                const [start, end] = line.time;
                const duration = (end - start) * 1000;

                if (player.seekTo && player.playVideo && player.pauseVideo && duration > 0) {
                    player.seekTo(start);
                    player.playVideo();

                    // (end - start) 시간 후에 비디오를 정지
                    clipTimeoutRef.current = setTimeout(() => {
                        player.pauseVideo();
                        clipTimeoutRef.current = null;
                    }, duration);
                }
            };

            // 재생 속도 변경 핸들러
            const handleRateChange = (e) => {
                const newRate = parseFloat(e.target.value);
                setPlaybackRate(newRate);
                // useEffect [player, playbackRate]가 플레이어 속도를 업데이트합니다.
            };

            // *** 단어 호버 핸들러 (팝업 고정 로직 추가)
            const handleWordHover = useCallback((e, baseForm) => {
                e.stopPropagation();
                if (pinnedWordData) return; // *** 팝업이 고정되어 있으면 호버 무시
                if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);

                const wordData = vocabMap.get(baseForm);
                if (wordData) {
                    const rect = e.target.getBoundingClientRect();
                    let x = rect.left;
                    let y = rect.bottom + 5;
                    const tooltipWidth = 320;
                    if (x + tooltipWidth > window.innerWidth) {
                        x = rect.right - tooltipWidth;
                        if (x < 0) x = 10;
                    }
                    const tooltipHeight = 200; // Approximate height
                    if (y + tooltipHeight > window.innerHeight + window.scrollY) {
                        y = rect.top - tooltipHeight - 5;
                    }
                    setHoverPopupData({ data: wordData, position: { x, y } });
                    setHighlightedVocab(wordData.term);

                    const vocabElement = vocabRefs.current[wordData.term];
                    if (vocabElement) {
                        vocabElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }, [vocabMap, pinnedWordData]); // *** pinnedWordData 의존성 추가

            // *** 단어 호버 해제 핸들러 (팝업 고정 로직 추가)
            const handleWordLeave = useCallback(() => {
                if (pinnedWordData) return; // *** 팝업이 고정되어 있으면 무시
                hoverTimeoutRef.current = setTimeout(() => {
                    setHoverPopupData(null);
                    setHighlightedVocab(null);
                }, 200);
            }, [pinnedWordData]); // *** pinnedWordData 의존성 추가

            // *** 단어 클릭 핸들러 (팝업 고정/해제)
            const handleWordClick = useCallback((e, baseForm) => {
                e.stopPropagation(); // 전역 클릭 리스너가 바로 실행되는 것을 방지
                const wordData = vocabMap.get(baseForm);
                if (!wordData) return;

                // 이미 고정된 단어를 다시 클릭한 경우, 고정 해제
                if (pinnedWordData && pinnedWordData.data.term === wordData.term) {
                    setPinnedWordData(null);
                    setHoverPopupData(null); // 호버 데이터도 초기화
                    setHighlightedVocab(null);
                } else {
                    // 새 단어를 클릭하여 고정
                    const rect = e.target.getBoundingClientRect();
                    let x = rect.left;
                    let y = rect.bottom + 5;
                    const tooltipWidth = 320;
                    if (x + tooltipWidth > window.innerWidth) {
                        x = rect.right - tooltipWidth;
                        if (x < 0) x = 10;
                    }
                    const tooltipHeight = 200; // Approximate height
                    if (y + tooltipHeight > window.innerHeight + window.scrollY) {
                        y = rect.top - tooltipHeight - 5;
                    }
                    
                    const newData = { data: wordData, position: { x, y } };
                    setPinnedWordData(newData); // 이 단어를 고정
                    setHoverPopupData(null); // 호버 팝업은 숨김
                    setHighlightedVocab(wordData.term);

                    // 어휘 목록 스크롤
                    const vocabElement = vocabRefs.current[wordData.term];
                    if (vocabElement) {
                        vocabElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }, [vocabMap, pinnedWordData]);

            const toggleTranslation = (lineId) => {
                setTranslationsVisible(prev => ({ ...prev, [lineId]: !prev[lineId] }));
            };

            return (
                <div className="video-materials-content md:flex md:flex-row md:gap-6">
                    {/* *** 툴팁 렌더링 로직: 고정된 팝업을 우선으로 보여줌 */}
                    {(pinnedWordData || hoverPopupData) && (
                        <HoverTooltip 
                            data={(pinnedWordData || hoverPopupData).data} 
                            position={(pinnedWordData || hoverPopupData).position} 
                        />
                    )}
                    {/* --- 비디오 플레이어 --- */}
                    <div ref={playerContainerRef} className="video-wrapper md:w-[41%] md:sticky top-8 z-40 bg-gray-50 py-4 no-print md:h-[calc(100vh-18rem)]">
                        <div className={`w-full rounded-xl shadow-lg border-4 border-white overflow-hidden transition-all duration-300 ease-in-out h-full`}>
                            <div id="youtube-player" className="w-full h-full"></div>
                        </div>
                        <div className="mt-4 flex flex-row justify-between items-center gap-4">
                            <label htmlFor="sync-toggle" className="flex items-center justify-between cursor-pointer bg-white py-1.5 px-3 rounded-lg shadow-md border w-auto flex-none">
                                <span className="text-xs font-medium text-gray-900 whitespace-nowrap">Auto-scroll</span>
                                <div className="relative ml-3">
                                    <input type="checkbox" id="sync-toggle" className="sr-only" checked={isSyncEnabled} onChange={() => setIsSyncEnabled(!isSyncEnabled)} />
                                    <div className={`block w-10 rounded-full transition-colors ${isSyncEnabled ? 'bg-green-500' : 'bg-gray-200'}`} style={{ height: '0.35cm' }}></div>
                                    <div className={`dot absolute left-1 top-[2.6px] bg-white w-2 h-2 rounded-full transition-transform ${isSyncEnabled ? 'transform translate-x-6' : ''}`}></div>
                                </div>
                            </label>
                            
                            <div className="flex items-center gap-2 bg-white py-1.5 px-3 rounded-lg shadow-md border w-auto flex-1">
                                <span className="text-xs font-medium text-gray-900">Speed</span>
                                <input
                                    type="range"
                                    min="0.60" // *** 최저 속도 0.60x로 변경
                                    max="1.20"
                                    step="0.01"
                                    value={playbackRate}
                                    onChange={handleRateChange}
                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mx-2"
                                    aria-label="Playback speed"
                                />
                                <span className="text-xs font-semibold text-green-700 w-12 text-right">{playbackRate.toFixed(2)}x</span>
                            </div>
                        </div>
                    </div>
                    {/* --- 스크립트 패널 --- */}
                    <div className="script-wrapper md:w-[59%] md:h-[calc(100vh-18rem)] md:overflow-y-auto relative" ref={scriptWrapperRef}>
                        <main className="flex-grow">
                            <div className="space-y-6">
                                {scriptContent.map(line => {
                                    const hasTranslation = !!line.eng;
                                    const isActive = activeScriptLine === line.id;

                                    if (line.kor.startsWith('•')) {
                                        return (
                                            <div key={line.id} ref={el => scriptLineRefs.current[line.id] = el}
                                                className={`p-3 my-2 rounded-lg transition-colors duration-300 ${isActive ? 'bg-yellow-100' : ''}`}>
                                                <p className="whitespace-pre-wrap text-lg text-gray-800">
                                                    <HighlightedText 
                                                        text={line.kor} 
                                                        highlightData={highlightData} 
                                                        onWordHover={handleWordHover} 
                                                        onWordLeave={handleWordLeave} 
                                                        onWordClick={handleWordClick} // *** 클릭 핸들러 전달
                                                        lineId={line.id} 
                                                        activeWordId={activeWordId} 
                                                    />
                                                </p>
                                                {translationsVisible[line.id] && hasTranslation && (
                                                    <p className="text-gray-600 text-base mt-2">{line.eng}</p>
                                                )}
                                                <div className="flex items-center gap-2 mt-2 no-print">
                                                    {hasTranslation && (
                                                        <button onClick={() => toggleTranslation(line.id)} className="text-xs text-gray-600 bg-gray-100 hover:bg-gray-200 px-2 py-1 rounded-md transition">
                                                            {translationsVisible[line.id] ? 'Hide translation' : 'Translation'}
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    }

                                    const isYuna = line.speaker === '스브스뉴스'; // 스브스뉴스도 왼쪽
                                    const bubbleWrapperClasses = `flex flex-col max-w-[100%] sm:max-w-[100%] ${isYuna ? 'items-start ml-3' : 'items-end self-end mr-3'}`;
                                    const bubbleBaseClasses = 'relative px-5 py-3 rounded-2xl shadow-md transition-colors duration-300';
                                    const yunaBubbleColor = 'bg-green-100';
                                    const woodyBubbleColor = 'bg-white';
                                    const activeBubbleColor = 'bg-yellow-100';
                                    // Determine tailClass based on speaker
                                    const tailClass = isYuna ? 'bubble-tail-left bubble-kkn20' : 'bubble-tail-right bubble-other';
                                    const bubbleClasses = `${bubbleBaseClasses} ${isActive ? activeBubbleColor : (isYuna ? yunaBubbleColor : woodyBubbleColor)} ${tailClass} ${isActive ? 'bubble-active' : ''}`;
                                    const speakerNameClasses = `font-bold mb-1 ${isYuna ? 'text-green-800' : 'text-blue-800'}`;

                                    return (
                                        <div key={line.id} ref={el => scriptLineRefs.current[line.id] = el} className="flex flex-col w-full">
                                            <div className={bubbleWrapperClasses}>
                                                <p className={`${speakerNameClasses} ${isYuna ? 'self-start' : 'self-end'}`}>{line.speaker}</p>
                                                <div className={bubbleClasses}>
                                                    <p className="whitespace-pre-wrap text-lg text-gray-800">
                                                        <HighlightedText 
                                                            text={line.kor} 
                                                            highlightData={highlightData} 
                                                            onWordHover={handleWordHover} 
                                                            onWordLeave={handleWordLeave} 
                                                            onWordClick={handleWordClick} // *** 클릭 핸들러 전달
                                                            lineId={line.id} 
                                                            activeWordId={activeWordId} 
                                                        />
                                                    </p>
                                                </div>
                                                <div className={`w-full flex flex-col ${isYuna ? 'items-start' : 'items-end'}`}>
                                                    {translationsVisible[line.id] && hasTranslation && (
                                                        <p className="text-gray-500 text-base mt-2 px-2">{line.eng}</p>
                                                    )}
                                                    <div className="flex items-center gap-2 mt-2 px-2 no-print">
                                                        {line.time && (
                                                            <button onClick={() => handlePlayClip(line)} className="text-xs px-2 py-1 rounded-md transition bg-gray-100 hover:bg-gray-200 text-gray-600">
                                                                Play Clip
                                                            </button>
                                                        )}
                                                        {hasTranslation && (
                                                            <button onClick={() => toggleTranslation(line.id)} className="text-xs text-gray-600 bg-gray-100 hover:bg-gray-200 px-2 py-1 rounded-md transition">
                                                                {translationsVisible[line.id] ? 'Hide translation' : 'Translation'}
                                                            </button>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </main>
                    </div>
                </div>
            )
        }

        // --- [퀴즈&토론] 탭 관련 컴포넌트 ---
        const ComprehensionQuiz = ({ sentences }) => {
            const { useState, useMemo } = React;
            const [selectedWords, setSelectedWords] = useState({});
            const [results, setResults] = useState({});
            const [translationsVisible, setTranslationsVisible] = useState({});
            const [hintsVisible, setHintsVisible] = useState({});

            const shuffledSentences = useMemo(() => {
                const shuffleArray = (array) => {
                    const newArray = [...array];
                    for (let i = newArray.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                    }
                    return newArray;
                };
                return sentences.map(sentence => ({ ...sentence, bank: shuffleArray(sentence.bank) }));
            }, [sentences]);

            const handleWordSelect = (id, word) => {
                setSelectedWords(prev => ({...prev, [id]: word}));
                const isCorrect = sentences.find(s => s.id === id).answer === word;
                setResults(prev => ({...prev, [id]: isCorrect}));
                setHintsVisible(prev => ({ ...prev, [id]: false }));
            };
            const handleToggleTranslation = (id) => { setTranslationsVisible(prev => ({...prev, [id]: !prev[id]})); };
            const handleToggleHint = (id) => { if (results[id] !== true) setHintsVisible(prev => ({...prev, [id]: !prev[id]})); };

            return (
                <div className="space-y-8">
                    {shuffledSentences.map((s, index) => (
                        <div key={s.id} className="p-6 border rounded-xl bg-white shadow-lg transition-all duration-300">
                            <p className="text-gray-700 font-bold text-lg mb-4">{index + 1}. 다음 빈칸에 알맞은 말을 고르세요. (Choose the correct word for the blank.)</p>
                            <div className="p-4 bg-gray-100 rounded-lg text-left mb-3 text-gray-900 text-xl font-bold">
                                {s.parts[0]}
                                <span className="inline-block bg-yellow-200 text-green-800 px-3 py-1 rounded-md font-extrabold mx-2">
                                    {hintsVisible[s.id] ? `[ ${s.eng_hint} ]` : (selectedWords[s.id] || '___')}
                                </span>
                                {s.parts[1]}
                                {results[s.id] === true && <span className="inline-block ml-2 text-green-500">✓</span>}
                                {results[s.id] === false && <span className="inline-block ml-2 text-red-500">✗</span>}
                            </div>
                            {translationsVisible[s.id] && (
                                <div className="text-gray-600 italic p-3 bg-gray-50 rounded-lg text-left mt-2 text-base">
                                    {results[s.id] ? (<span>{s.eng_parts[0]}<strong className="text-green-600">{s.eng_answer}</strong>{s.eng_parts[1]}</span>)
                                    : (<span>{s.eng_parts[0]}<span className="font-bold">___</span>{s.eng_parts[1]}</span>)}
                                </div>
                            )}
                            <div className="text-left mb-4 flex gap-2">
                                <button onClick={() => handleToggleHint(s.id)} className="text-xs bg-yellow-200 hover:bg-yellow-300 text-yellow-800 font-bold py-1 px-3 rounded-full transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled={results[s.id] === true}>힌트 (Hint)</button>
                                <button onClick={() => handleToggleTranslation(s.id)} className="text-xs bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-1 px-3 rounded-full transition duration-200">번역 (Translation)</button>
                            </div>
                            <div className="flex justify-start flex-wrap gap-3">
                                {s.bank.map(word => (
                                    <button
                                        key={word}
                                        onClick={() => handleWordSelect(s.id, word)}
                                        className={`px-4 py-2 rounded-lg text-lg font-bold transition-all transform hover:scale-105 shadow-md ${selectedWords[s.id] === word ? (results[s.id] ? 'bg-green-500 text-white ring-2 ring-opacity-50 ring-green-400' : 'bg-red-500 text-white ring-2 ring-red-300') : 'bg-white text-gray-800 hover:bg-gray-100 border'}`}
                                    >{word}</button>
                                ))}
                            </div>
                            {results[s.id] !== undefined && (
                                <div className={`mt-4 p-4 border-l-4 rounded-r-lg ${results[s.id] ? 'bg-green-50 border-green-400' : 'bg-red-50 border-red-400'}`}>
                                    <p className={`font-bold ${results[s.id] ? 'text-green-800' : 'text-red-800'} flex items-center gap-2 text-lg`}>{results[s.id] ? 'Correct!' : 'Try again.'}</p>
                                    <p className="mt-2 text-gray-700 text-base italic">{results[s.id] ? s.eng_explanation : s.eng_wrongAnswerExplanations[selectedWords[s.id]]}</p>
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            );
        };

        const SentenceChecker = ({ value, onChange, placeholder, question }) => {
            const { useState } = React;
            const [feedback, setFeedback] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            const checkSentence = async () => {
                if (!value || value.trim() === '') {
                    setError("문장을 입력해야 피드백을 받을 수 있어요.");
                    setFeedback(null); return;
                }
                setIsLoading(true); setError(null); setFeedback(null);
                const prompt = `You are an advanced Korean language tutor AI for B1-C2 level learners. Analyze the user's sentence in response to a specific question. The user's answer is in Korean. Your entire response MUST be a JSON object, with all string values in Korean (ending in -요) and English.\n\nQuestion: "${question}"\nUser's Answer: "${value}"\n\nYour response MUST be a JSON object with the specified schema.`;
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: { type: "OBJECT", properties: { "is_relevant": { "type": "BOOLEAN" }, "relevance_feedback_kor": { "type": "STRING", "nullable": true }, "relevance_feedback_eng": { "type": "STRING", "nullable": true }, "is_correct": { "type": "BOOLEAN", "nullable": true }, "feedback_message_kor": { "type": "STRING", "nullable": true }, "feedback_message_eng": { "type": "STRING", "nullable": true }, "corrected_sentence": { "type": "STRING", "nullable": true }, "explanation_kor": { "type": "STRING", "nullable": true }, "explanation_eng": { "type": "STRING", "nullable": true }, "alternative_expressions": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "expression_kor": { "type": "STRING" }, "expression_eng": { "type": "STRING" } }, "required": ["expression_kor", "expression_eng"] } } }, "required": ["is_relevant"] }
                    }
                };
                const apiKey = ""; // NOTE: The API key is intentionally left blank.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();

                    // Enhanced error handling for API response
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0 && result.candidates[0].content.parts[0].text) {
                        try {
                            const parsedJson = JSON.parse(result.candidates[0].content.parts[0].text);
                            setFeedback(parsedJson);
                        } catch (parseError) {
                            console.error("Error parsing JSON response:", parseError, result.candidates[0].content.parts[0].text);
                            setError("AI의 응답 형식이 올바르지 않아 처리할 수 없어요.");
                        }
                    } else {
                        console.error("Invalid API response structure:", result);
                        setError("AI의 응답을 처리하는 데 문제가 발생했어요.");
                    }
                } catch (err) {
                    console.error("Error checking sentence:", err);
                    setError("문장 검사에 실패했어요. 네트워크 연결을 확인하거나 잠시 후 다시 시도해 주세요.");
                }
                finally { setIsLoading(false); }
            };


            const renderFeedbackSection = (title, content) => (content && content.length > 0 && (
                <div>
                    <p className="text-gray-800 font-bold text-[17px]">{title}</p>
                    {Array.isArray(content) ? (
                        <ul className="list-disc list-inside space-y-2 mt-1">
                            {content.map((item, index) => (
                                <li key={index} className="text-gray-600 text-[16px]">
                                    <p className="font-medium">{item.expression_kor || item.sentence_kor}</p>
                                    <p className="text-gray-500 italic text-sm">{item.expression_eng || item.sentence_eng}</p>
                                </li>
                            ))}
                        </ul>
                    ) : (<p className="text-gray-700 font-medium text-[18px]">{content}</p>)}
                </div>
            ));

            return (
                <div>
                    <textarea className="w-full p-3 border rounded-md focus:ring-2 focus:ring-green-400 transition text-lg" rows="3" placeholder={placeholder} value={value} onChange={onChange} />
                    <button onClick={checkSentence} disabled={isLoading} className="mt-3 flex items-center justify-center gap-2 bg-green-200 text-gray-900 py-2 px-4 rounded-md transition-colors hover:bg-green-300 disabled:opacity-50 disabled:cursor-wait font-semibold text-[14px]">
                        {isLoading ? <Spinner className="w-5 h-5" /> : '✨'} {isLoading ? '피드백 생성 중...' : 'AI에게 피드백 받기'}
                    </button>
                    {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
                    {feedback && (
                        <div className="mt-4 p-4 bg-green-50 border-l-4 border-green-100 rounded-r-lg space-y-4">
                            {!feedback.is_relevant && ( <div><p className="font-bold text-red-800 flex items-center gap-2 text-lg">{feedback.relevance_feedback_kor}</p><p className="text-gray-600 italic">{feedback.relevance_feedback_eng}</p></div> )}
                            {feedback.is_relevant && feedback.is_correct && ( <div><p className="font-bold text-green-800 flex items-center gap-2 text-lg"><ThumbsUp className="w-5 h-5"/> {feedback.feedback_message_kor}</p><p className="text-gray-600 italic">{feedback.feedback_message_eng}</p></div> )}
                            {feedback.is_relevant && !feedback.is_correct && (<>
                                {feedback.corrected_sentence && ( <div><p className="text-gray-800 font-bold text-[17px]">✨ 수정된 문장:</p><p className="text-gray-700 font-medium text-[18px]">{feedback.corrected_sentence}</p></div> )}
                                {(feedback.explanation_kor || feedback.explanation_eng) && ( <div><p className="text-gray-800 font-bold text-[17px]">설명:</p>{feedback.explanation_kor && <p className="text-gray-600 text-[16px]">{feedback.explanation_kor}</p>}{feedback.explanation_eng && <p className="text-gray-500 italic mt-1 text-[15px]">{feedback.explanation_eng}</p>}</div> )}
                            </>)}
                            {feedback.alternative_expressions && feedback.alternative_expressions.length > 0 && renderFeedbackSection('💡 다른 표현:', feedback.alternative_expressions)}
                        </div>
                    )}
                </div>
            );
        };

        const DiscussionSection = ({ questions }) => {
            const { useState } = React;
            const [translationsVisible, setTranslationsVisible] = useState({});
            const [userQuestionAnswers, setUserQuestionAnswers] = useState({});
            const toggleTranslation = (id) => { setTranslationsVisible(prev => ({ ...prev, [id]: !prev[id] })); };

            return (
                <div className="space-y-10">
                    {questions.map((q) => (
                        <div key={q.num} className="p-6 border rounded-xl bg-white shadow-lg">
                            <p className="text-gray-900 text-xl font-bold">{q.num}. {q.kor}</p>
                            {translationsVisible[`q-${q.num}`] && (<p className="whitespace-pre-wrap text-gray-600 italic mt-1 text-base">{q.eng}</p>)}
                            <button onClick={() => toggleTranslation(`q-${q.num}`)} className="text-xs text-gray-800 bg-gray-200 hover:bg-gray-300 font-bold py-1 px-3 rounded-full transition duration-200 mt-2 mb-6">번역 (Translation)</button>
                            {q.vocab && q.vocab.length > 0 && (
                                <div className="mt-4 space-y-4">
                                    <h3 className="font-bold text-lg text-gray-800">📍핵심 표현 (Essential phrases)</h3>
                                    {q.vocab.map((v, i) => (
                                        <div key={i} className="pl-4 border-l-2 border-gray-200 py-2">
                                            <p className="font-semibold text-green-700 text-lg">{v.term}: <span className="font-medium text-gray-700 text-base">{v.meaning_eng}</span></p>
                                            {/* '대화 속에서 살펴보기' 섹션이 여기서 삭제되었습니다. */}
                                        </div>
                                    ))}
                                </div>
                            )}
                            <div className="mt-6">
                                <h3 className="font-bold text-lg text-gray-800 mb-2">핵심 표현을 사용해서 질문에 대답해 보세요.</h3>
                                <SentenceChecker
                                    value={userQuestionAnswers[`q-${q.num}`] || ''}
                                    onChange={(e) => setUserQuestionAnswers(prev => ({...prev, [`q-${q.num}`]: e.target.value}))}
                                    placeholder="여기에 답변을 입력하세요 (Type your response here)"
                                    question={q.kor}
                                />
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        const Tabs = ({ tabs }) => {
            const { useState } = React;
            const [activeTab, setActiveTab] = useState(0);
            return (
                <div>
                    <div className="border-b border-gray-200 no-print">
                        <nav className="-mb-px flex space-x-6" aria-label="Tabs">
                            {tabs.map((tab, index) => (
                                <button
                                    key={tab.id} // *** 고유 ID 사용
                                    onClick={() => setActiveTab(index)}
                                    className={`${ index === activeTab ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'} whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors flex items-center gap-2`}
                                >{tab.icon} {tab.name}</button>
                            ))}
                        </nav>
                    </div>
                    <div className="pt-10">{tabs[activeTab].content}</div>
                </div>
            );
        };

        // --- 메인 App 컴포넌트 ---
        const App = () => {
            const { useState, useEffect, useMemo } = React;
            const [containerWidth, setContainerWidth] = useState('30cm');
            const [layoutMode, setLayoutMode] = useState('large');

            useEffect(() => {
                const handleResize = () => {
                    const heightInPx = window.innerHeight; const widthInPx = window.innerWidth;
                    const isMobileDevice = /Mobi|Android/i.test(navigator.userAgent);
                    const isTabletDevice = /iPad|Android(?!.*Mobi)/i.test(navigator.userAgent);
                    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
                    let newMode = 'large'; let newContainerWidth = '30cm';

                    if ((isMobileDevice || isTabletDevice) && isPortrait) { newMode = 'mobile'; newContainerWidth = '100%'; }
                    else {
                        if (heightInPx < 832) { newMode = 'split'; newContainerWidth = '100%'; }
                        else if (heightInPx < 907) { newMode = 'small'; newContainerWidth = '22cm'; }
                        else if (heightInPx < 983) { newMode = 'medium'; newContainerWidth = '24cm'; }
                        else { newMode = 'large'; newContainerWidth = '30cm'; }
                    }
                    setContainerWidth(newContainerWidth); setLayoutMode(newMode); document.body.dataset.layoutMode = newMode;
                    const baseWidthPx = 30 * 37.795; let effectiveWidthPx;
                    if (newContainerWidth === '100%') { effectiveWidthPx = widthInPx; }
                    else { const cmValue = parseFloat(newContainerWidth); effectiveWidthPx = cmValue * 37.795; }
                    if (newMode !== 'large') { const scale = Math.min(1.0, effectiveWidthPx / baseWidthPx); const finalScale = Math.max(0.8, scale); document.documentElement.style.fontSize = `${16 * finalScale}px`; }
                    else { document.documentElement.style.fontSize = '16px'; }
                };
                window.addEventListener('resize', handleResize); handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const { scriptContent, vocabAndGrammarList, sentences, discussionQuestions } = useMemo(() => {
                // Data structures remain multi-line for readability
                const scriptContent = [
                    { id: 's1', speaker: '스브스뉴스', kor: '요즘 미국 사람들은 술 대신 마시는 게 있었으니,', time: [0.000, 3.100], eng: "These days, Americans have something they drink instead of alcohol," },
                    { id: 's2', speaker: '스브스뉴스', kor: '바로 "대마 음료"라고 합니다.', time: [3.100, 4.700], eng: 'and it\'s called "cannabis-infused drinks".' },
                    { id: 's3', speaker: '스브스뉴스', kor: '“현재 술을 마신다"라고 답한 미국 성인이 역대 최저치를 기록할 정도.', time: [5.550, 10.277], eng: 'It\'s to the point where American adults who answered "I currently drink" has hit an all-time low.' },
                    { id: 's4', speaker: '스브스뉴스', kor: '대마 음료란 대마초의 성분 중 THC를 첨가하여 만든 음료를 의미하는데요.', time: [10.300, 15.415], eng: 'A "cannabis drink" means a beverage made by adding THC, one of the components of marijuana.' },
                    { id: 's5', speaker: '스브스뉴스', kor: '이런 대마 음료 시장이 미국에서 엄청나게 커지고 있고,', time: [15.415, 18.785], eng: 'This cannabis drink market is growing enormously in the US, and,' },
                    { id: 's6', speaker: '스브스뉴스', kor: '여러 브랜드의 대마 음료를 마셔 볼 수 있는 축제가 열리기도 하고,', time: [18.819, 22.523], eng: 'festivals are held where you can try various brands of cannabis drinks, and' },
                    { id: 's7', speaker: '스브스뉴스', kor: '대마 음료를 레스토랑과 온라인에서도 쉽게 구매할 수 있다는데.', time: [22.556, 26.260], eng: 'they say you can easily buy cannabis drinks at restaurants and online.' },
                    { id: 's8', speaker: '스브스뉴스', kor: '가장 큰 이유는 술을 대하는 MZ세대의 태도가 변했기 때문이라는데요.', time: [26.293, 30.898], eng: 'The biggest reason, they say, is because the MZ generation\'s attitude towards alcohol has changed.' },
                    { id: 's9', speaker: '스브스뉴스', kor: '실제로 미국의 18세에서 34세의 음주율 변화가 가장 크기도 한데,', time: [30.931, 35.200], eng: 'In fact, the change in the drinking rate for 18 to 34-year-olds in the US is the largest,' },
                    { id: 's10', speaker: '스브스뉴스', kor: '미국뿐만 아니라 전 세계적으로 건강을 중요하게 생각하는 게 트렌드가 되니,', time: [35.235, 39.673], eng: 'and as prioritizing health has become a trend not just in the US but globally,' },
                    { id: 's11', speaker: '스브스뉴스', kor: '술을 멀리하는 마음까지 이어지게 된 것!', time: [39.700, 42.476], eng: 'it has led to a mindset of avoiding alcohol!' },
                    { id: 's12', speaker: '스브스뉴스', kor: '"술이 건강에 안 좋으니까 술 대신 대마 음료를 마시자...?"', time: [42.509, 45.946], eng: '"Alcohol is unhealthy, so let\'s drink cannabis drinks instead...?"' },
                    { id: 's13', speaker: '스브스뉴스', kor: '이게 대체 어떻게 나온 생각이죠?', time: [45.979, 48.115], eng: 'Where on earth did this idea come from?' },
                    { id: 's14', speaker: '김민지(SWRLOperation 매니저)', kor: '술은 너무 역사가 깊잖아요.', time: [48.315, 50.517], eng: 'You know, alcohol has such a deep history.' },
                    { id: 's15', speaker: '김민지(SWRLOperation 매니저)', kor: '건강에 해롭다는 게 이제 의학이 발달을 하면서', time: [50.550, 53.787], eng: 'The fact that it\'s harmful to health, as medical science developed,' },
                    { id: 's16', speaker: '김민지(SWRLOperation 매니저)', kor: '간에 해롭고 숙취가 있고 이런 걸 알게 된 거고,', time: [53.820, 57.491], eng: 'we came to know it\'s harmful to the liver and causes hangovers, and,' },
                    { id: 's17', speaker: '김민지(SWRLOperation 매니저)', kor: '대마는 아직은 우울증 약으로도 치료를 하는 거고,', time: [57.524, 61.428], eng: 'cannabis is still used as a treatment for depression, and,' },
                    { id: 's18', speaker: '김민지(SWRLOperation 매니저)', kor: '정신 안정에 도움이 되고,', time: [61.461, 63.096], eng: 'it helps with mental stability, and' },
                    { id: 's19', speaker: '김민지(SWRLOperation 매니저)', kor: '이런 얘기도 많단 말이에요.', time: [63.130, 65.096], eng: 'there are many stories like that.' }
                ];
                const vocabAndGrammarList = [
                    { "term": "술 대신 마시는 게 있었으니", "mainDef": "There was something they drink instead of alcohol, so...", "subDefs": [ { "subTerm": "• 대신", "subDef": "instead of; in place of." }, { "subTerm": "• 마시는 게", "subDef": "the thing (they) drink (colloial form of -는 것이)." }, { "subTerm": "• -(으)니", "subDef": "grammar ending indicating reason or discovery ('because' or 'so...')." } ], "variants": ["술 대신 마시는 게 있었으니"], "examples": [ { "kor": "커피 대신 물을 마셔요.", "eng": "I drink water instead of coffee." }, { "kor": "이것은 마시는 게 아니에요.", "eng": "This is not a (thing for) drinking." }, { "kor": "지금 비가 오니, 집에 있어요.", "eng": "It's raining now, so I'm at home." } ] },
                    { "term": "대마 음료", "mainDef": "hemp beverage; cannabis drink.", "subDefs": [ { "subTerm": "• 대마", "subDef": "hemp; cannabis." }, { "subTerm": "• 음료", "subDef": "beverage; drink." } ], "variants": ["대마 음료", "대마 음료란", "대마 음료 시장이", "대마 음료를"], "examples": [ { "kor": "'대마'는 식물이에요.", "eng": "Hemp is a plant." }, { "kor": "저는 시원한 음료를 좋아해요.", "eng": "I like cold drinks." } ] },
                    { "term": "-라고 하다", "mainDef": "to be called; it is said that...", "subDefs": [ { "subTerm": "• -(이)라고 하다", "subDef": "indirect quotation for nouns ('to be called [N]') or statements ('to say that [S]').\n(e.g., 대마 음료라고 합니다 - It is called a 'hemp beverage'.)" } ], "variants": ["라고 합니다"], "examples": [ { "kor": "제 이름은 김민수라고 합니다.", "eng": "My name is Minsu Kim." } ] },
                    { "term": "”현재 술을 마신다\"라고 답한 미국 성인", "mainDef": "American adults who answered that they 'currently drink alcohol'.", "subDefs": [ { "subTerm": "• -라고 답하다", "subDef": "to answer that..." }, { "subTerm": "• -ㄴ", "subDef": "past tense modifier describing the following noun ('who did...').\n(e.g., 답한 성인 - adults who answered.)" }, { "subTerm": "• 성인", "subDef": "adult." } ], "variants": ["“현재 술을 마신다\"라고 답한 미국 성인이"], "examples": [ { "kor": "'네'라고 답했어요.", "eng": "I answered 'yes'." }, { "kor": "어제 먹은 빵이 맛있어요.", "eng": "The bread I ate yesterday is delicious." }, { "kor": "그는 이제 성인이에요.", "eng": "He is an adult now." } ] },
                    { "term": "역대 최저치를 기록할 정도", "mainDef": "to the point of recording the lowest level in history.", "subDefs": [ { "subTerm": "• 역대", "subDef": "in history; of all time." }, { "subTerm": "• 최저치", "subDef": "the lowest value/level." }, { "subTerm": "• 기록하다", "subDef": "to record; to mark." }, { "subTerm": "• -ㄹ/을 정도", "subDef": "to the extent that...; to the point of..." } ], "variants": ["역대 최저치를 기록할 정도"], "examples": [ { "kor": "오늘은 역대 가장 더운 날이에요.", "eng": "Today is the hottest day in history." }, { "kor": "온도가 최저치로 떨어졌어요.", "eng": "The temperature dropped to its lowest point." }, { "kor": "이름을 여기에 기록하세요.", "eng": "Please record your name here." }, { "kor": "너무 매워서 울 정도예요.", "eng": "It's so spicy to the point of crying." } ] },
                    { "term": "대마초의 성분 중", "mainDef": "among the components of cannabis.", "subDefs": [ { "subTerm": "• 대마초", "subDef": "cannabis; marijuana." }, { "subTerm": "• 성분", "subDef": "component; ingredient." }, { "subTerm": "• 중", "subDef": "among; in the middle of." } ], "variants": ["대마초의 성분 중"], "examples": [ { "kor": "'대마초'는 불법이에요.", "eng": "Marijuana is illegal." }, { "kor": "이 약의 성분이 뭐예요?", "eng": "What are the ingredients of this medicine?" }, { "kor": "사과, 바나나, 오렌지 중에서 사과를 좋아해요.", "eng": "Among apples, bananas, and oranges, I like apples." } ] },
                    { "term": "THC를 첨가하여 만든 음료", "mainDef": "a beverage made by adding THC.", "subDefs": [ { "subTerm": "• THC", "subDef": "THC (Tetrahydrocannabinol)." }, { "subTerm": "• 첨가하다", "subDef": "to add." }, { "subTerm": "• -여(서)", "subDef": "links actions in sequence ('do this *and then*...')." }, { "subTerm": "• -ㄴ/은", "subDef": "past tense modifier describing the following noun ('which was made...').\n(e.g., 만든 음료 - a beverage that was made.)" }, { "subTerm": "• 음료", "subDef": "beverage; drink." } ], "variants": ["THC를 첨가하여 만든 음료를", "THC를 첨가하여 만든 음료"], "examples": [ { "kor": "THC는 성분이에요.", "eng": "THC is an ingredient." }, { "kor": "설탕을 조금 첨가해요.", "eng": "Add a little sugar." }, { "kor": "일어나서 밥을 먹어요.", "eng": "I wake up and then eat." }, { "kor": "어제 본 영화가 재미있어요.", "eng": "The movie I watched yesterday is fun." }, { "kor": "무슨 음료 마실래요?", "eng": "What drink do you want?" } ] },
                    { "term": "의미하는데요", "mainDef": "it means... (and...)", "subDefs": [ { "subTerm": "• 의미하다", "subDef": "to mean; to signify." }, { "subTerm": "• -는데요", "subDef": "grammar ending used to provide background information or introduce a new topic.\n(e.g., ...음료를 의미하는데요 - It means... a beverage, and...)" } ], "variants": ["의미하는데요"], "examples": [ { "kor": "이 단어는 '사랑'을 의미해요.", "eng": "This word means 'love'." }, { "kor": "지금 공부하는데요.", "eng": "I'm studying right now..." } ] },
                    { "term": "엄청나게 커지고 있고", "mainDef": "is getting incredibly large (and...)", "subDefs": [ { "subTerm": "• 엄청나게", "subDef": "incredibly; enormously." }, { "subTerm": "• 커지다", "subDef": "to get bigger; to grow." }, { "subTerm": "• -고 있다", "subDef": "present progressive ('is ...-ing').\n(e.g., 커지고 있다 - is growing.)" } ], "variants": ["엄청나게 커지고 있고"], "examples": [ { "kor": "날씨가 엄청나게 추워요.", "eng": "The weather is incredibly cold." }, { "kor": "강아지가 많이 커졌어요.", "eng": "The puppy has gotten much bigger." }, { "kor": "친구가 밥을 먹고 있어요.", "eng": "My friend is eating." } ] },
                    { "term": "여러 브랜드의 대마 음료를 마셔 볼 수 있는 축제", "mainDef": "a festival where you can try drinking various brands of hemp beverages.", "subDefs": [ { "subTerm": "• 여러", "subDef": "various; many." }, { "subTerm": "• -아/어 볼 수 있다", "subDef": "can try (doing something).\n(e.g., 마셔 볼 수 있다 - can try drinking.)" }, { "subTerm": "• -는", "subDef": "present tense modifier describing the following noun ('where you can...')." }, { "subTerm": "• 축제", "subDef": "festival." } ], "variants": ["여러 브랜드의 대마 음료를 마셔 볼 수 있는 축제가", "여러 브랜드의 대마 음료를 마셔 볼 수 있는 축제"], "examples": [ { "kor": "저는 여러 나라에 가고 싶어요.", "eng": "I want to go to various countries." }, { "kor": "한국 음식을 먹어 볼 수 있어요.", "eng": "You can try eating Korean food." }, { "kor": "저기 가는 사람이 제 친구예요.", "eng": "The person going over there is my friend." }, { "kor": "오늘 학교에서 축제를 해요.", "eng": "There is a festival at school today." } ] },
                    { "term": "열리기도 하고", "mainDef": "it is also held (and...)", "subDefs": [ { "subTerm": "• 축제가 열리다", "subDef": "a festival is held." }, { "subTerm": "• -기도 하다", "subDef": "to also (do something); sometimes (do something).\n(e.g., 열리기도 하고 - it is also held, and...)" } ], "variants": ["열리기도 하고"], "examples": [ { "kor": "봄에 꽃 축제가 열려요.", "eng": "A flower festival is held in the spring." }, { "kor": "주말에 영화를 보기도 해요.", "eng": "I sometimes watch movies on the weekend." } ] },
                    { "term": "쉽게 구매할 수 있다는데", "mainDef": "they say you can easily purchase it (and...)", "subDefs": [ { "subTerm": "• 쉽게", "subDef": "easily." }, { "subTerm": "• 구매하다", "subDef": "to purchase." }, { "subTerm": "• -는데", "subDef": "grammar ending used to report something heard ('they say...'). Contraction of -다고 하는데." } ], "variants": ["쉽게 구매할 수 있다는데"], "examples": [ { "kor": "이 문제는 쉬워요. 쉽게 풀 수 있어요.", "eng": "This problem is easy. I can solve it easily." }, { "kor": "가방을 구매했어요.", "eng": "I purchased a bag." }, { "kor": "그 식당 맛있는데...", "eng": "That restaurant is delicious..." } ] },
                    { "term": "가장 큰 이유", "mainDef": "the biggest reason.", "subDefs": [ { "subTerm": "• 가장", "subDef": "the most; -est (superlative)." }, { "subTerm": "• 이유", "subDef": "reason." } ], "variants": ["가장 큰 이유는", "가장 큰 이유"], "examples": [ { "kor": "이것이 가장 좋아요.", "eng": "This is the best." }, { "kor": "학교에 늦은 이유가 뭐예요?", "eng": "What is the reason you are late for school?" } ] },
                    { "term": "술을 대하는 MZ세대의 태도", "mainDef": "the attitude of Gen Z towards alcohol.", "subDefs": [ { "subTerm": "• MZ세대", "subDef": "Gen Z (MZ Generation)." }, { "subTerm": "• (을/를) 대하는 태도", "subDef": "attitude towards (something/someone)." } ], "variants": ["술을 대하는 MZ세대의 태도가", "술을 대하는 MZ세대의 태도"], "examples": [ { "kor": "MZ세대는 젊은 사람들이에요.", "eng": "Gen Z are young people." }, { "kor": "친구를 대하는 태도가 좋아요.", "eng": "His/her attitude towards friends is good." } ] },
                    { "term": "변했기 때문이라는데요.", "mainDef": "they say it's because it has changed.", "subDefs": [ { "subTerm": "• 태도가 변하다", "subDef": "attitude changes." }, { "subTerm": "• -기 때문이라는데요", "subDef": "Combination of '-기 때문에' (because) + '-(이)라고 하다' (they say) + '-는데요' (background info).\n(e.g., ...변했기 때문이라는데요 - ...they say it's because it has changed.)" } ], "variants": ["변했기 때문이라는데요"], "examples": [ { "kor": "그 사람이 친절하게 변했어요.", "eng": "That person's attitude changed to be kind." }, { "kor": "오늘 춥기 때문이라는데요.", "eng": "They say it's because it's cold today." } ] },
                    { "term": "실제로", "mainDef": "actually; in reality.", "subDefs": [], "variants": ["실제로"], "examples": [ { "kor": "그는 실제로 키가 커요.", "eng": "He is actually tall." } ] },
                    { "term": "18세에서 34세의 음주율 변화가 가장 크기도 한데,", "mainDef": "the change in the drinking rate for 18-34 year olds is also the largest, and...", "subDefs": [ { "subTerm": "• 음주율", "subDef": "drinking rate." }, { "subTerm": "• 변화", "subDef": "change." }, { "subTerm": "• -기도 하다", "subDef": "to also (be something)." }, { "subTerm": "• -ㄴ/은데", "subDef": "grammar ending providing background context ('...and...' or '...but...')." } ], "variants": ["18세에서 34세의 음주율 변화가 가장 크기도 한데"], "examples": [ { "kor": "이 나라의 음주율이 높아요.", "eng": "This country's drinking rate is high." }, { "kor": "날씨의 변화가 심해요.", "eng": "The change in weather is severe." }, { "kor": "저는 가끔 울기도 해요.", "eng": "I also cry sometimes." }, { "kor": "이 옷은 예쁜데, 좀 비싸요.", "eng": "These clothes are pretty, but a bit expensive." } ] },
                    { "term": "미국뿐만 아니라 전 세계적으로", "mainDef": "not only in the US, but also globally.", "subDefs": [ { "subTerm": "• -뿐만 아니라", "subDef": "not only... but also..." }, { "subTerm": "• 전 세계적으로", "subDef": "globally; worldwide." } ], "variants": ["미국뿐만 아니라 전 세계적으로"], "examples": [ { "kor": "사과뿐만 아니라 바나나도 좋아해요.", "eng": "I like not only apples but also bananas." }, { "kor": "BTS는 전 세계적으로 유명해요.", "eng": "BTS is famous worldwide." } ] },
                    { "term": "건강을 중요하게 생각하는 게", "mainDef": "thinking of health as important (is)...", "subDefs": [ { "subTerm": "• 건강", "subDef": "health." }, { "subTerm": "• 중요하게 생각하다", "subDef": "to think of (something) as important." }, { "subTerm": "• -는 게", "subDef": "the act of... (colloial form of -는 것이).\n(e.g., ...생각하는 게 트렌드가 되니 - ...thinking (of it as important) became a trend, so...)" } ], "variants": ["건강을 중요하게 생각하는 게"], "examples": [ { "kor": "건강이 중요해요.", "eng": "Health is important." }, { "kor": "저는 가족을 중요하게 생각해요.", "eng": "I think of my family as important." }, { "kor": "매일 운동하는 게 좋아요.", "eng": "Exercising every day is good." } ] },
                    { "term": "트렌드가 되니", "mainDef": "since it became a trend...", "subDefs": [ { "subTerm": "• 트렌드", "subDef": "trend." }, { "subTerm": "• -니", "subDef": "grammar ending indicating reason ('because' or 'since')." } ], "variants": ["트렌드가 되니"], "examples": [ { "kor": "요즘 트렌드예요.", "eng": "It's the trend these days." }, { "kor": "배가 고프니, 밥을 먹어요.", "eng": "I'm hungry, so I'm eating." } ] },
                    { "term": "술을 멀리하는 마음까지 이어지게 된 것", "mainDef": "it led to the mindset of avoiding alcohol.", "subDefs": [ { "subTerm": "• 멀리하다", "subDef": "to avoid; to keep at a distance." }, { "subTerm": "• -는", "subDef": "modifier describing the following noun ('mindset of avoiding...')." }, { "subTerm": "• 마음이 이어지다", "subDef": "a feeling/mindset is connected to; leads to." }, { "subTerm": "• -는 것", "subDef": "the act of...; the fact that... (nominalization)." } ], "variants": ["술을 멀리하는 마음까지 이어지게 된 것"], "examples": [ { "kor": "나쁜 친구는 멀리하세요.", "eng": "Stay away from bad friends." }, { "kor": "지금 읽는 책이 재미있어요.", "eng": "The book I am reading now is fun." }, { "kor": "두 사람의 마음이 이어졌어요.", "eng": "The two people's hearts connected." }, { "kor": "노래하는 것을 좋아해요.", "eng": "I like singing." } ] },
                    { "term": "술이 건강에 안 좋으니까", "mainDef": "because alcohol is not good for health...", "subDefs": [ { "subTerm": "• 건강", "subDef": "health." }, { "subTerm": "• -니까", "subDef": "grammar ending indicating a strong reason ('because...')." } ], "variants": ["술이 건강에 안 좋으니까"], "examples": [ { "kor": "건강을 위해 운동해요.", "eng": "I exercise for health." }, { "kor": "날씨가 좋으니까, 공원에 가요.", "eng": "The weather is nice, so let's go to the park." } ] },
                    { "term": "술 대신", "mainDef": "instead of alcohol.", "subDefs": [ { "subTerm": "• 대신", "subDef": "instead of; in place of." } ], "variants": ["술 대신"], "examples": [ { "kor": "밥 대신 빵을 먹었어요.", "eng": "I ate bread instead of rice." } ] },
                    { "term": "이게 대체 어떻게 나온 생각이죠?", "mainDef": "How on earth did this idea come about?", "subDefs": [ { "subTerm": "• 이게 대체", "subDef": "this, on earth... (adds emphasis)." }, { "subTerm": "• 생각이 나오다", "subDef": "an idea comes out/appears." } ], "variants": ["이게 대체 어떻게 나온 생각이죠"], "examples": [ { "kor": "이게 대체 뭐예요?", "eng": "What on earth is this?" }, { "kor": "좋은 생각이 나왔어요.", "eng": "A good idea came up." } ] },
                    { "term": "술은 너무 역사가 깊잖아요", "mainDef": "Alcohol has a very deep history, you know.", "subDefs": [ { "subTerm": "• 역사", "subDef": "history." }, { "subTerm": "• 깊다", "subDef": "to be deep." }, { "subTerm": "• -잖아요", "subDef": "grammar ending used to state something the listener should already know ('...you know')." } ], "variants": ["술은 너무 역사가 깊잖아요"], "examples": [ { "kor": "역사 공부는 재미있어요.", "eng": "Studying history is fun." }, { "kor": "이 호수는 물이 깊어요.", "eng": "This lake is deep." }, { "kor": "오늘 일요일이잖아요.", "eng": "It's Sunday today, you know." } ] },
                    { "term": "건강에 해롭다는 게", "mainDef": "the fact that it's harmful to health...", "subDefs": [ { "subTerm": "• 건강", "subDef": "health." }, { "subTerm": "• 해롭다", "subDef": "to be harmful." }, { "subTerm": "• -는 게", "subDef": "the fact that... (colloial form of -는 것이)." } ], "variants": ["건강에 해롭다는 게"], "examples": [ { "kor": "건강이 최고예요.", "eng": "Health is the best." }, { "kor": "담배는 몸에 해로워요.", "eng": "Smoking is harmful to the body." }, { "kor": "공부하는 게 중요해요.", "eng": "Studying is important." } ] },
                    { "term": "의학이 발달을 하면서", "mainDef": "as medicine developed...", "subDefs": [ { "subTerm": "• 의학", "subDef": "medicine (the field of study)." }, { "subTerm": "• 발달하다", "subDef": "to develop." }, { "subTerm": "• -(으)면서", "subDef": "grammar ending indicating simultaneous action ('while') or a change over time ('as')." } ], "variants": ["의학이 발달을 하면서"], "examples": [ { "kor": "그는 의학을 공부해요.", "eng": "He studies medicine." }, { "kor": "도시가 많이 발달했어요.", "eng": "The city has developed a lot." }, { "kor": "음악을 들으면서 숙제해요.", "eng": "I do homework while listening to music." } ] },
                    { "term": "간에 해롭고 숙취가 있고", "mainDef": "it's harmful to the liver and there's a hangover...", "subDefs": [ { "subTerm": "• 간", "subDef": "liver." }, { "subTerm": "• 해롭다", "subDef": "to be harmful." }, { "subTerm": "• 숙취가 있다", "subDef": "to have a hangover." } ], "variants": ["간에 해롭고 숙취가 있고"], "examples": [ { "kor": "간은 중요해요.", "eng": "The liver is important." }, { "kor": "이것은 몸에 해로워요.", "eng": "This is bad for the body." }, { "kor": "어제 술을 마셔서 숙취가 있어요.", "eng": "I have a hangover because I drank yesterday." } ] },
                    { "term": "이런 걸 알게 된 거고", "mainDef": "we came to know this (and...)", "subDefs": [ { "subTerm": "• 이런 걸", "subDef": "this kind of thing (colloial)." }, { "subTerm": "• 알게 되다", "subDef": "to come to know; to find out." }, { "subTerm": "• -ㄴ/은 거고", "subDef": "colloial ending stating a fact or situation ('it's that... and...')." } ], "variants": ["이런 걸 알게 된 거고"], "examples": [ { "kor": "저는 이런 걸 좋아해요.", "eng": "I like this kind of thing." }, { "kor": "그의 비밀을 알게 됐어요.", "eng": "I came to know his secret." }, { "kor": "그냥 친구인 거고, 애인은 아니에요.", "eng": "We're just friends, not lovers." } ] },
                    { "term": "우울증 약으로도 치료를 하는 거고", "mainDef": "it's also used to treat depression (and...)", "subDefs": [ { "subTerm": "• 우울증 약", "subDef": "depression medicine." }, { "subTerm": "• -으로 치료하다", "subDef": "to treat with..." }, { "subTerm": "• -는 거고", "subDef": "colloial ending stating a fact or situation ('it's that... and...')." } ], "variants": ["우울증 약으로도 치료를 하는 거고"], "examples": [ { "kor": "그는 우울증 약을 먹어요.", "eng": "He takes depression medicine." }, { "kor": "이 병은 약으로 치료해요.", "eng": "This disease is treated with medicine." }, { "kor": "이건 먹는 거고, 저건 마시는 거예요.", "eng": "This is for eating, and that is for drinking." } ] },
                    { "term": "정신 안정에 도움이 되고", "mainDef": "it helps with mental stability (and...)", "subDefs": [ { "subTerm": "• 정신 안정", "subDef": "mental stability." }, { "subTerm": "• 도움이 되다", "subDef": "to be helpful; to help." } ], "variants": ["정신 안정에 도움이 되고"], "examples": [ { "kor": "음악은 정신 안정에 좋아요.", "eng": "Music is good for mental stability." }, { "kor": "이 책은 공부에 도움이 돼요.", "eng": "This book is helpful for studying." } ] },
                    { "term": "이런 얘기도 많단 말이에요", "mainDef": "there's a lot of talk like this, you see.", "subDefs": [ { "subTerm": "• 이런 얘기", "subDef": "this kind of talk/story." }, { "subTerm": "• -ㄴ/은/단 말이에요", "subDef": "grammar ending used to emphasize or re-state a fact ('I'm saying...'; '...you see')." } ], "variants": ["이런 얘기도 많단 말이에요"], "examples": [ { "kor": "이런 얘기는 재미없어요.", "eng": "This kind of story is not fun." }, { "kor": "저는 학생이란 말이에요.", "eng": "I'm telling you I'm a student." } ] }
                ];
                const sentences = [
                    { id: 1, parts: ["요즘 미국 사람들은 술 대신 '", "' 음료를 마신다고 해요."], answer: "대마", bank: ["대마", "커피", "에너지", "마차"], eng_parts: ["People in the US are reportedly drinking '", "' beverages instead of alcohol these days."], eng_answer: "cannabis", eng_hint: "The main topic of the news report.", eng_explanation: "Correct. The script introduces '대마 음료' (cannabis drinks) as the beverage replacing alcohol.", eng_wrongAnswerExplanations: { "커피": "Coffee is not mentioned as the replacement.", "에너지": "Energy drinks are not mentioned.", "마차": "Matcha is not mentioned." } },
                    { id: 2, parts: ["대마 음료란 THC를 '", "' 만든 음료예요."], answer: "첨가하여", bank: ["첨가하여", "참가하여", "사서", "빼서"], eng_parts: ["Cannabis drinks are beverages made by '", "' THC."], eng_answer: "adding", eng_hint: "Verb (ending in -아/어서) meaning 'to add' or 'to include'.", eng_explanation: "Correct. '첨가하여' means 'by adding'. The script says the drinks are made by adding THC. The '-아/어서' indicates the method.", eng_wrongAnswerExplanations: { "참가하여": "This means 'by participating' and sounds similar but is incorrect.", "사서": "This means 'by buying'.", "빼서": "This means 'by removing' or 'by subtracting', which is the opposite." } },
                    { id: 3, parts: ["대마 음료 시장이 커진 가장 큰 이유는 MZ세대의 술을 대하는 '", "'가 변했기 때문이에요."], answer: "태도", bank: ["태도", "대화", "법", "건강"], eng_parts: ["The biggest reason the cannabis drink market has grown is because the '", "' of the MZ generation toward alcohol has changed."], eng_answer: "attitude", eng_hint: "A noun meaning 'attitude' or 'stance'.", eng_explanation: "Correct. The script says the biggest reason is the change in '태도' (attitude) of the MZ generation.", eng_wrongAnswerExplanations: { "대화": "This means 'conversation'.", "법": "This means 'law'.", "건강": "Health is a related trend, but 'attitude' is the specific word used." } },
                    { id: 4, parts: ["술은 역사가 깊지만, 의학이 발달하면서 '", "' 밝혀졌어요."], answer: "건강에 해롭다는 게", bank: ["건강에 해롭다는 게", "정신 안정에 좋다는 게", "숙취가 없다는 게", "우울증에 좋다는 게"], eng_parts: ["Alcohol has a long history, but as medicine developed, it was revealed '", "'."], eng_answer: "that it is harmful to health", eng_hint: "The negative effect of alcohol mentioned by Speaker 2.", eng_explanation: "Correct. Speaker 2 explains that '건강에 해롭다는 게' (that it is harmful to health) was discovered as medicine advanced.", eng_wrongAnswerExplanations: { "정신 안정에 좋다는 게": "This was said about cannabis, not alcohol.", "숙취가 없다는 게": "This is incorrect; hangovers are a known harm of alcohol.", "우울증에 좋다는 게": "This was said about cannabis, not alcohol." } },
                    { id: 5, parts: ["건강을 중요하게 생각하는 게 트렌드가 돼서 사람들이 술을 '", "'."], answer: "멀리한다고 해요", bank: ["멀리한다고 해요", "좋아한다고 해요", "가까이한다고 해요", "산다고 해요"], eng_parts: ["Because prioritizing health has become a trend, people are '", "' alcohol."], eng_answer: "reportedly staying away from", eng_hint: "A verb phrase meaning 'to keep a distance from' or 'to avoid'.", eng_explanation: "Correct. '멀리한다고 해요' means 'they say people are staying away from'. This is the result of the health trend.", eng_wrongAnswerExplanations: { "좋아한다고 해요": "This means 'reportedly like', which is the opposite.", "가까이한다고 해요": "This means 'reportedly stay close to', which is the opposite.", "산다고 해요": "This means 'reportedly buy', which is not the main point." } },
                    { id: 6, parts: ["반면에, 대마는 '", "'에 도움이 된다고 해요."], answer: "정신 안정", bank: ["정신 안정", "집중력", "운동", "정신병"], eng_parts: ["On the other hand, cannabis reportedly helps with '", "'."], eng_answer: "mental stability", eng_hint: "A positive effect on the mind mentioned by Speaker 2.", eng_explanation: "Correct. Speaker 2 says there are many stories about cannabis helping with '정신 안정' (mental stability).", eng_wrongAnswerExplanations: { "집중력": "This means 'concentration' and was not mentioned.", "운동": "This means 'exercise' and was not mentioned.", "정신병": "This means 'mental illness', which is the opposite of what was said." } },
                    { id: 7, parts: ["대마는 우울증을 '", "' 약으로 사용해요."], answer: "치료하는", bank: ["치료하는", "만드는", "먹는", "마시는"], eng_parts: ["Cannabis is used as medicine that '", "' depression."], eng_answer: "treats", eng_hint: "Present tense modifier of '치료하다' (to treat/cure an illness).", eng_explanation: "Correct. '치료하는' is the modifier form of '치료하다' (to treat). The script says it's used as a '우울증 약' (depression medicine).", eng_wrongAnswerExplanations: { "만드는": "This means 'makes' or 'causes', which is the opposite.", "먹는": "This means 'eating', which is not the purpose of the medicine itself.", "마시는": "This means 'drinking'. While the topic is drinks, the verb for medicine's function is 'to treat'." } },
                    { id: 8, parts: ["하지만 '", "' 대마 음료가 건강에 좋을까요?"], answer: "실제로", bank: ["실제로", "가짜로", "우연히", "대충"], eng_parts: ["But are cannabis drinks '", "' healthy?"], eng_answer: "really", eng_hint: "An adverb meaning 'really', 'actually', or 'in reality'.", eng_explanation: "Correct. '실제로' (really/actually) is used to question if the perceived benefits are true. This reflects the news's skeptical question: '이게 대체 어떻게 나온 생각이죠?'", eng_wrongAnswerExplanations: { "가짜로": "This means 'falsely' or 'fake'.", "우연히": "This means 'by chance'.", "대충": "This means 'roughly' or 'carelessly'." } }
                ];
                const discussionQuestions = [
                    { num: 1, kor: "여러분의 나라에서도 젊은 사람들이 술을 많이 안 마셔요?", eng: "In your country, do young people also not drink much alcohol?", vocab: [ { term: "젊은 사람들", meaning_eng: "Young people" }, { term: "술을 많이 안 마시다", meaning_eng: "To not drink much alcohol" } ] },
                    { num: 2, kor: "\"술이 건강에 안 좋으니까 술 대신 대마 음료를 마시자\"라는 생각에 동의해요?", eng: "Do you agree with the idea that \"Alcohol is unhealthy, so let's drink cannabis drinks instead\"?", vocab: [ { term: "술 대신", meaning_eng: "Instead of alcohol" }, { term: "건강에 안 좋다", meaning_eng: "Is unhealthy / bad for health" }, { term: "동의해요?", meaning_eng: "Do you agree?" } ] },
                    { num: 3, kor: "대마가 \"우울증 치료\"와 \"정신 안정\"에 도움이 된다는 주장이 있어요. 그런데 의사의 처방 없이 대마 음료를 마시는 것이 안전할까요?", eng: "There's a claim that cannabis helps with 'treating depression' and 'mental stability'. But is it safe to drink cannabis drinks without a doctor's prescription?", vocab: [ { term: "우울증 치료", meaning_eng: "Treating depression" }, { term: "정신 안정", meaning_eng: "Mental stability" }, { term: "의사의 처방 없이", meaning_eng: "Without a doctor's prescription" }, { term: "안전할까요?", meaning_eng: "Is it safe?" } ] },
                    { num: 4, kor: "대마 음료도 술처럼 건강에 해롭다고 생각해요? 사람들이 대마 음료를 계속 마시면 10년 후에는 어떤 문제가 나타날까요?", eng: "Do you think cannabis drinks are also harmful to health, like alcohol? If people keep drinking them, what problems might appear in 10 years?", vocab: [ { term: "건강에 해롭다", meaning_eng: "To be harmful to health" }, { term: "계속 마시면", meaning_eng: "If (one) keeps drinking" }, { term: "문제가 나타나다", meaning_eng: "Problems appear" } ] },
                    { num: 5, kor: "MZ세대가 술을 멀리하는 이유가 정말 건강 때문일까요? 다른 이유가 있을까요?", eng: "Is health really the reason the MZ generation is staying away from alcohol? Could there be other reasons?", vocab: [ { term: "술을 멀리하다", meaning_eng: "To stay away from alcohol" }, { term: "건강 때문", meaning_eng: "Because of health" }, { term: "다른 이유", meaning_eng: "Other reasons" } ] },
                    { num: 6, kor: "여러분의 나라에서 대마 음료가 합법화된다면 찬성할 거예요? 반대할 거예요?", eng: "If cannabis drinks were legalized in your country, would you agree (support) or disagree (oppose)?", vocab: [ { term: "합법화되다", meaning_eng: "To be legalized" }, { term: "찬성하다", meaning_eng: "To agree, to support" }, { term: "반대하다", meaning_eng: "To disagree, to oppose" } ] },
                    { num: 7, kor: "대마 음료 말고, 어떤 음료가 파티에서 술을 대체할 수 있을까요? 어떤 것이 있을까요?", eng: "Besides cannabis drinks, what other beverages could replace alcohol at parties? What kinds are there?", vocab: [ { term: "... 말고", meaning_eng: "Besides..." }, { term: "대체하다", meaning_eng: "To replace, to substitute" }, { term: "어떤 것이 있을까요?", meaning_eng: "What kinds are there?" } ] },
                    { num: 8, kor: "대마 음료처럼 '건강'이 새로운 '트렌드'가 되는 현상에 대해 어떻게 생각해요? (예: 제로 슈거 음료, 비건 음식 등)", eng: "What do you think about the phenomenon of 'health' becoming a new 'trend', like with cannabis drinks? (e.g., zero-sugar drinks, vegan food, etc.)", vocab: [ { term: "트렌드", meaning_eng: "Trend" }, { term: "현상", meaning_eng: "Phenomenon" }, { term: "제로 슈거", meaning_eng: "Zero sugar" }, { term: "비건 음식", meaning_eng: "Vegan food" } ] }
                ];
                return { scriptContent, vocabAndGrammarList, sentences, discussionQuestions };
            }, []);

            const { vocabMap, highlightData } = useMemo(() => {
                const vocabMap = new Map(vocabAndGrammarList.map(item => [item.term, item]));
                const wordMap = new Map();
                vocabAndGrammarList.forEach(item => wordMap.set(item.term, item));
                const allWords = Array.from(wordMap.keys()).sort((a, b) => b.length - a.length);
                const regexParts = [];
                allWords.forEach(word => {
                    const item = wordMap.get(word);
                    if (item.variants) item.variants.forEach(v => regexParts.push(v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')));
                    let processed = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\s*');
                    if (word.endsWith('다')) {
                        const parts = word.split(' ');
                        const lastPart = parts[parts.length - 1];
                        if (lastPart.endsWith('다')) {
                            const stem = lastPart.slice(0, -1).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            const firstParts = parts.slice(0, -1).map(p => p.replace(/[.*+?^${}()|[\]\D]/g, '\\$&'));
                            regexParts.push([...firstParts, `${stem}[가-힣]*`].join('\\s*'));
                        } else { regexParts.push(`${processed.slice(0, -1)}[가-힣]*`); }
                    } else { regexParts.push(processed); }
                });
                const regexString = [...new Set(regexParts)].sort((a,b) => b.length - a.length).join('|');
                return { vocabMap, highlightData: { regex: new RegExp(`(${regexString})`, 'g'), wordMap, sortedWords: allWords }};
            }, [vocabAndGrammarList]);

            const tabs = useMemo(() => {
                const baseTabs = [
                    { id: 'script', name: <><span className="sm:text-base">대화 스크립트</span><span className="text-xs sm:text-sm text-gray-400 ml-1">(Transcript)</span></>, icon: <Video className="w-5 h-5"/>, content: <VideoMaterialsTab scriptContent={scriptContent} vocabAndGrammarList={vocabAndGrammarList} highlightData={highlightData} vocabMap={vocabMap} /> },
                    { id: 'vocab', name: <><span className="sm:text-base">핵심 어휘</span><span className="text-xs sm:text-sm text-gray-400 ml-1">(Key Vocabulary)</span></>, icon: <List className="w-5 h-5"/>, content: (
                        <div>
                            <h2 className="text-3xl font-extrabold text-gray-900 mb-8 flex items-center gap-3"><List className="w-8 h-8 text-green-600"/> 핵심 어휘 (Key Vocabulary)</h2>
                            <div className="w-full overflow-y-auto" style={{maxHeight: `calc(100vh - 150px)`}}>
                                <div className="border rounded-lg bg-white p-2 shadow-lg">
                                    <div className="space-y-1">{vocabAndGrammarList.map(item => <VocabItem key={item.term} item={item} />)}</div>
                                </div>
                            </div>
                        </div>
                    )},
                    { id: 'quiz', name: <><span className="sm:text-base">내용 확인 퀴즈</span><span className="text-xs sm:text-sm text-gray-400 ml-1">(Comprehension Check-Up)</span></>, icon: <BookOpen className="w-5 h-5"/>, content: (
                        <div>
                            <h2 className="text-3xl font-extrabold text-gray-900 mb-8 flex items-center gap-3"><BookOpen className="w-8 h-8 text-green-600"/> 내용 확인 퀴즈 (Comprehension Check-Up)</h2>
                            <ComprehensionQuiz sentences={sentences} />
                        </div>
                    )},
                    { id: 'discussion', name: <><span className="sm:text-base">생각해 보기</span><span className="text-xs sm:text-sm text-gray-400 ml-1">(Food For Thought)</span></>, icon: <MessageSquare className="w-5 h-5"/>, content: (
                        <div>
                            <h2 className="text-3xl font-extrabold text-gray-900 mb-8 flex items-center gap-3"><MessageSquare className="w-8 h-8 text-green-600"/> 생각해 보기 (Food For Thought)</h2>
                            <DiscussionSection questions={discussionQuestions} />
                        </div>
                    ) }
                ];
                return baseTabs;
            }, [layoutMode, scriptContent, vocabAndGrammarList, sentences, discussionQuestions, highlightData, vocabMap]);

            return (
                <div className="bg-gray-50 text-gray-800 p-4 sm:p-6 md:p-8">
                    <div className="mx-auto transition-all duration-300" style={{ maxWidth: containerWidth }}>
                        <header className="text-center mb-12">
                            <h1 className="text-4xl md:text-5xl font-black text-gray-900 mb-2">술보다 대마 음료가 건강에 좋을까요?</h1>
                            <p className="text-xl text-gray-500" style={{fontFamily: "'Nanum Gothic', sans-serif"}}>Are cannabis-infused drinks healthier than alcohol?</p>
                        </header>
                        <Tabs tabs={tabs} />
                        {/* // *** 하단 중복 어휘 목록 제거
                        (layoutMode === 'mobile' || layoutMode === 'split') && (
                            <div className="pt-10">
                                <h2 className="text-3xl font-extrabold text-gray-900 mb-8 flex items-center gap-3"><List className="w-8 h-8 text-green-600"/> 핵심 어휘 (Key Vocabulary)</h2>
                                <div className="w-full">
                                    <div className="border rounded-lg bg-white p-2 shadow-lg">
                                        <div className="space-y-1">{vocabAndGrammarList.map(item => <VocabItem key={item.term} item={item} />)}</div>
                                    </div>
                                </div>
                            </div>
                        )
                        */}
                    </div>
                </div>
            );
        };
    
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
